// Meysam Aghighi
// Edmond-karp implementation modified version of geeksforgeeks.org

#include <iostream>
#include <vector>
#include <queue>
#include <climits>
#include <cstring>
using namespace std;

struct edge{
	int to, w, flow;
	edge(int _to, int _w, int _flow): to(_to), w(_w), flow(_flow){} // member initialization
};

#define N 505
int n,m,s,t,u,v,w;
long long g[N][N], rg[N][N];
int p[N];

bool bfs(int s, int t, int parent[]){
    bool visited[V]; memset(visited, 0, sizeof(visited)); visited[s] = true;
    queue <int> q; q.push(s);
    parent[s] = -1;
    while (!q.empty()){
        int u = q.front(); q.pop();
        for (int v=0; v<V; v++){
            if (visited[v]==false && rg[u][v] > 0){
                q.push(v);
                parent[v] = u;
                visited[v] = true;
            }
        }
    }
    return (visited[t] == true);
}


void fordFulkerson(int **graph, int V, int s, int t){
    int u, v;
    long long **rg;
    rg = new long long * [V];
    for (u = 0; u < V; u++){
    	rg[u] = new long long[V];
        for (v = 0; v < V; v++)
             rg[u][v] = graph[u][v];
    }
// 	print rg
//    for (int i=0;i<V;i++){
//    	for (int j=0;j<V;j++)
//    		cout << graph[i][j] << "\t";
//    	cout << endl;
//    }

    int parent[V];
    long long max_flow = 0;

    while (bfs(rg, V, s, t, parent)){
        long long path_flow = INT_MAX;
        for (v=t; v!=s; v=parent[v]){
            u = parent[v];
            path_flow = min(path_flow, rg[u][v]);
        }
        for (v=t; v != s; v=parent[v]){
            u = parent[v];
            rg[u][v] -= path_flow;
            rg[v][u] += path_flow;
        }
        max_flow += path_flow;
    }

    // Print output
    int nodes = 0;
    vector<edge> used_edges;
    bool marked[V]; memset(marked,false,sizeof(marked));
    for (int i=0;i<V;i++){
    	for (int j=0;j<V;j++){
    		if (graph[i][j] > 0 && rg[i][j] < graph[i][j]){
//    			cerr << i << " " << j << " " << graph[i][j] << " " << rg[i][j] << endl;
    			used_edges.push_back(edge(i,j,graph[i][j]-rg[i][j]));
    			if(!marked[i]) marked[i] = true , nodes++;
    			if(!marked[j]) marked[j] = true , nodes++;
    		}
    	}
    }
    if (nodes == 0) nodes = 2;
    cout << nodes << " " << max_flow << " " << used_edges.size() << endl;
    for (int i=0;i<used_edges.size();i++)
    	cout << used_edges[i].to << " " << used_edges[i].w << " " << used_edges[i].flow << endl;
}

int main(){
	cin >> n >> m >> s >> t;
//	vector<edge> g[n];
	int **g; g = new int * [n];
	for (int i=0;i<n;i++){
		g[i] = new int[n];
		for (int j=0;j<n;j++) g[i][j] = 0;
	}
	for (int i=0;i<m;i++){
		cin >> u >> v >> w;
//		g[u].push_back(edge(v,w,0));
		g[u][v] = w;
	}

	fordFulkerson(g,n,s,t);


	return 0;
}
