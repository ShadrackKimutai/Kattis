// Meysam Aghighi

#include <iostream>
#include <vector>
#include <queue>
#include <climits>
#include <cstring>
using namespace std;

struct edge{
	int to, w, flow;
	edge(int _to, int _w, int _flow): to(_to), w(_w), flow(_flow){} // member initialization
};

#define N 505
int n,m,s,t,u,v,w;
long long g[N][N], rg[N][N], max_flow, path_flow;
int p[N];

long long bfs(int s, int t){
    bool visited[n]; memset(visited,false,sizeof(visited)); visited[s] = true;
    queue <int> q; q.push(s);
    p[s] = -1;
    int f[n]; f[s] = INT_MAX;
    while (!q.empty()){
        int u = q.front(); q.pop();
        for (int v=0; v<n; v++){
            if (visited[v]==false && rg[u][v] > 0){
                q.push(v);
                p[v] = u;
                visited[v] = true;
                f[v] = min(f[u],rg[u][v]);
            }
        }
    }
    return (visited[t]?m[t]:0);
}


void fordFulkerson(int s, int t){
    max_flow = 0;
    while (bfs(s, t)){
        path_flow = INT_MAX;
        for (v=t; v!=s; v=p[v]){
            u = p[v];
            path_flow = min(path_flow, rg[u][v]);
        }
        for (v=t; v != s; v=p[v]){
            u = p[v];
            rg[u][v] -= path_flow;
            rg[v][u] += path_flow;
        }
        max_flow += path_flow;
    }

    // Print output
    int nodes = 0;
    vector<edge> used_edges;
    bool marked[n]; memset(marked,false,sizeof(marked));
    for (int i=0;i<n;i++){
    	for (int j=0;j<n;j++){
    		if (g[i][j] > 0 && rg[i][j] < g[i][j]){
    			used_edges.push_back(edge(i,j,g[i][j]-rg[i][j]));
    			if(!marked[i]) marked[i] = true , nodes++;
    			if(!marked[j]) marked[j] = true , nodes++;
    		}
    	}
    }
    if (nodes == 0) nodes = 2;
    cout << nodes << " " << max_flow << " " << used_edges.size() << endl;
    for (int i=0;i<used_edges.size();i++)
    	cout << used_edges[i].to << " " << used_edges[i].w << " " << used_edges[i].flow << endl;
}

int main(){
	cin >> n >> m >> s >> t;
	memset(g,0,sizeof(g));
	memset(rg,0,sizeof(rg));
	for (int i=0;i<m;i++){
		cin >> u >> v >> w;
		g[u][v] = rg[u][v] = w;
	}
	fordFulkerson(s,t);
	return 0;
}
